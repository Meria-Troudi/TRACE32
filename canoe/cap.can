/*@!Encoding:1252*/
variables
{
  const dword INVALID = ~0;
  dword    sock  = INVALID;
  char     buf[1024];
  char     pathBuf[512];
  char     msg[600];
  int      recvLen;int cnt;
enum {IDLE, CONNECT, WAIT, RUNNING} state = IDLE;
}

on start
{
  sysSetVariableString(sysvar::cmm::path, "");
  sysSetVariableString(sysvar::cmm::result, "");
  write("?? Starting Python server…");
  sysExec("C:\\Program Files\\Python311\\python.exe", "CLI.py", "C:\\Users\\meria\\Desktop\\TRACE32_TEST\\TRACE32");
}

on sysvar cmm::path
{
  char newPath[1024];
  sysGetVariableString(sysvar::cmm::path, newPath, elcount(newPath));
 if (newPath[0] == '\0'){
    write(" Path cleared, back to IDLE");
    state = IDLE;return;
  }
  if (newPath[0] != '\0' && state == IDLE){
    cnt = sysGetVariableInt(sysvar::cmm::count);
    if (cnt < 1) cnt = 1;

    write(" Path set to: %s \n count:%d", newPath,cnt);
    if (sock != INVALID) TcpClose(sock); // Clean any old connection
    write("?? Opening TCP connection…");

    sock = TcpOpen(0,0);
    TcpConnect(sock, 0x0100007F, 12345);
    state = CONNECT;
  }
 
}
onTcpConnect(dword s, long result)
{
  if (s != sock) return;
  if (result != 0){
    write("? Connect failed (err=%d)", result);
    TcpClose(sock); sock = INVALID;
    state = IDLE;
     return;
  }else{
    write("? TCP connected");
    TcpReceive(sock, buf, elcount(buf));
    TcpSend(sock, "PING\n", 5);
    state = WAIT;
  }
}

void OnTcpReceive(dword s, long result,
                  dword addr, dword port,
                  char buffer[], dword size)
{
  if (s != sock) return;

  if (result != 0 || size <= 0)
  {
    write("?? Disconnected (r=%d,s=%d)", result, size);
    TcpClose(sock); sock = INVALID;
    state = IDLE;
    return;
  }

  recvLen = size < elcount(buf) ? size : elcount(buf)-1;
  memcpy(buf, buffer, recvLen);
  buf[recvLen] = '\0';

  write("?? From Python: %s", buf);

  if (state == WAIT && strncmp(buf, "PONG", 4) == 0)
  {
    sysGetVariableString(sysvar::cmm::path, pathBuf, elcount(pathBuf));
    snprintf(msg, elcount(msg), "RUN_CMM|%s|%d\n", pathBuf, cnt);

    write("?? Sending RUN_CMM: %s", msg);
    TcpSend(sock, msg, strlen(msg));
    state = RUNNING; // <-- FIXED: Wait for result now
  }
  else if (state == RUNNING)
  {
    sysSetVariableString(sysvar::cmm::result, buf);
    write("? Result stored from Python. Returning to IDLE.");
    state = IDLE;
  }

  TcpReceive(sock, buf, elcount(buf));
}

// 7) Cleanup
on preStop
{
  if (sock != INVALID)
    TcpClose(sock);
}
